<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>üé• Diffusion Control Panel</title>
  <link rel="icon" href="static/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="static/style.css">
  <meta name="description" content="Sende Live-Bilder deiner Webcam an Stable Diffusion zur Bildgenerierung.">
  <style>
  </style>
</head>
<body>

  <div class="left">
    <h1>üé• Kamera</h1>
      <video id="webcam" autoplay muted playsinline></video>

      <label for="model_select">Modell:</label>
      <select id="model_select">
	<option value="hakurei/waifu-diffusion">hakurei/waifu-diffusion</option>
	<option value="stabilityai/stable-diffusion-2-1-base">stabilityai/stable-diffusion-2-1-base</option>
	<option value="stabilityai/stable-diffusion-2-1">stabilityai/stable-diffusion-2-1</option>
        <option value="dreamlike-art/dreamlike-photoreal-2.0">dreamlike-art/dreamlike-photoreal-2.0</option>
        <option value="lykon/dreamshaper-8">lykon/dreamshaper-8</option>
        <option value="runwayml/stable-diffusion-v1-5">runwayml/stable-diffusion-v1-5</option>
        <option value="gsdf/Counterfeit-V2.5">gsdf/Counterfeit-V2.5</option>
	<option value="SG161222/Realistic_Vision_V2.0">SG161222/Realistic_Vision_V2.0</option>
	<option value="darkstorm2150/Protogen_x3.4">darkstorm2150/Protogen_x3.4</option>
	<option value="CompVis/stable-diffusion-v1-4">CompVis/stable-diffusion-v1-4</option>
	<option value="prompthero/openjourney">prompthero/openjourney</option>
      </select>

      <br>

      <label for="prompt">Prompt:</label>
      <input type="text" id="prompt" placeholder="Beschreibe den Stil‚Ä¶" />
      <small>üëâ Was soll im Bild zu sehen sein? Beschreibe es m√∂glichst genau.</small>

      <label for="negative_prompt">Negativer Prompt:</label>
      <input type="text" id="negative_prompt" placeholder="Negativer Prompt (z.B. unerw√ºnschte Inhalte)‚Ä¶" value="cartoon, painting, drawing, blurry, lowres, text, watermark" />
      <small>üö´ Was soll NICHT im Bild vorkommen? (z.‚ÄØB. unscharf, Text, bestimmte Objekte)</small>

      <div class="slider-group">
        <label for="num_inference_steps">Inference Steps: <span id="steps_val">5</span></label>
        <input type="range" id="num_inference_steps" min="2" max="50" value="5"
              oninput="document.getElementById('steps_val').innerText = this.value">
        <small>‚öôÔ∏è Wie oft wird das Bild verfeinert? Mehr Schritte = bessere Details (aber langsamer).</small>
      </div>

      <div class="slider-group">
        <label for="guidance_scale">Guidance Scale: <span id="scale_val">7.5</span></label>
        <input type="range" id="guidance_scale" min="1" max="15" step="0.1" value="7.5"
              oninput="document.getElementById('scale_val').innerText = this.value">
        <small>üéØ Wie stark soll der Prompt beachtet werden? H√∂her = n√§her an deiner Beschreibung.</small>
      </div>

      <div class="slider-group">
        <label for="strength">Image Strength: <span id="strength_val">0.35</span></label>
        <input type="range" id="strength" min="0.3" max="0.9" step="0.01" value="0.5"
              oninput="document.getElementById('strength_val').innerText = this.value">
        <small>üñºÔ∏è Wie stark soll das aktuelle Kamerabild ver√§ndert werden? Wenig = mehr Original.</small>
      </div>

      <div class="info"><span id="latency">Warte auf Bild‚Ä¶</span></div>
      <div id="error" class="error" style="display:none;"></div>
    </div>


  <div class="right">
    <h1>üé® Ergebnis</h1>
    <img id="processedImage" style="display:none; width:512px; height: 512px;;" />
  </div>

<script>
  const video = document.getElementById('webcam');
  const promptInput = document.getElementById('prompt');
  const latencyDisplay = document.getElementById('latency');
  const errorBox = document.getElementById('error');

  let delay = 1000;

  async function startWebcam() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      video.srcObject = stream;
    } catch (err) {
      showError("Kein Zugriff auf Kamera: " + err.message);
    }
  }

  async function getFrameBlob(video) {
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    return new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
  }

let oldImageData = null;
const morphCanvas = document.createElement('canvas');
const morphCtx = morphCanvas.getContext('2d');
const processedImage = document.getElementById("processedImage");

// Setup morphCanvas size gleich dem Bild
function setupMorphCanvas(width, height) {
  morphCanvas.width = width;
  morphCanvas.height = height;
  processedImage.parentNode.insertBefore(morphCanvas, processedImage);
  processedImage.style.display = "none";
}

  async function morphImages(oldImg, newImg, duration = 300) {
	  if (!oldImg) {
		  morphCanvas.style.display = 'none';
		  processedImage.style.display = 'block';
		  processedImage.src = newImg.src;
		  oldImageData = new Image();
		  oldImageData.src = newImg.src; // neues Image-Objekt
		  return;
	  }

	  if (morphCanvas.width !== newImg.width || morphCanvas.height !== newImg.height) {
		  setupMorphCanvas(512, 512);
	  }

	  morphCanvas.style.display = 'block';
	  processedImage.style.display = 'none';

	  return new Promise(resolve => {
		  let start = null;

		  function animate(timestamp) {
			  if (!start) start = timestamp;
			  let progress = (timestamp - start) / duration;
			  if (progress > 1) progress = 1;

			  morphCtx.clearRect(0, 0, morphCanvas.width, morphCanvas.height);
			  morphCtx.globalAlpha = 1;
			  morphCtx.drawImage(oldImg, 0, 0);
			  morphCtx.globalAlpha = progress;
			  morphCtx.drawImage(newImg, 0, 0);

			  if (progress < 1) {
				  requestAnimationFrame(animate);
			  } else {
				  // Warten bis neues Bild geladen ist, bevor sichtbar
				  const newProcessedImg = new Image();
				  newProcessedImg.onload = () => {
					  morphCanvas.style.display = 'none';
					  processedImage.style.display = 'block';
					  processedImage.src = newProcessedImg.src;
					  morphCtx.clearRect(0, 0, morphCanvas.width, morphCanvas.height);
					  oldImageData = newProcessedImg;
					  resolve();
				  };
				  newProcessedImg.src = newImg.src;
			  }
		  }
		  requestAnimationFrame(animate);
	  });
  }

var avg_latency = [];

  function get_avg_latency () {
	  if(avg_latency.length == 0) {
		  return 1000;
	  }

	  let sum = 0;
	  for(let i = 0; i < avg_latency.length; i++) {
		  sum += avg_latency[i];
	  }
	  return sum / avg_latency.length;
  }

  async function sendImage() {
	  const blob = await getFrameBlob(video);
	  if (!blob) return showError("Konnte Bildblob nicht erstellen");

	  const form = new FormData();
	  form.append("strength", document.getElementById('strength').value);
	  form.append("input", blob, "frame.png");
	  form.append("prompt", promptInput.value || "");
	  form.append("negative_prompt", document.getElementById('negative_prompt').value || "");
	  form.append("model", document.getElementById('model_select').value);
	  form.append("steps", document.getElementById('num_inference_steps').value);
	  form.append("scale", document.getElementById('guidance_scale').value);
	  form.append("model", document.getElementById('model_select').value);
	  form.append("seed", "33");

	  const start = performance.now();

	  try {
		  const res = await fetch("/generate", { method: "POST", body: form });
		  if (!res.ok) throw new Error("Server antwortete mit Status " + res.status);

		  // Blob statt Text
		  const blob = await res.blob();
		  const objectUrl = URL.createObjectURL(blob);

		  const newImg = new Image();
		  newImg.onload = async () => {
			  URL.revokeObjectURL(objectUrl); // aufr√§umen
			  await morphImages(oldImageData, newImg, Math.max(200, 0.9 * Math.floor(get_avg_latency())));
			  const latency = (performance.now() - start) / 1000;
			  avg_latency.push(latency);
			  latencyDisplay.textContent = `Verarbeitung: ${latency.toFixed(2)} Sekunden`;
			  errorBox.style.display = "none";
		  };
		  newImg.src = objectUrl;

	  } catch (e) {
		  showError("Fehler beim Senden: " + e.message);
	  }
  }

  function showError(msg) {
    errorBox.textContent = msg;
    errorBox.style.display = "block";
  }

  async function loop() {
	  while (1) {
		  await sendImage();
	  }
  }

  startWebcam().then(loop);
</script>

</body>
</html>
